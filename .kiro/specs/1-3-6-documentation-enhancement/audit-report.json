{
  "auditDate": "2026-02-02T16:31:23.475Z",
  "summary": {
    "totalFiles": 23,
    "totalPublicFunctions": 55,
    "documentedFunctions": 21,
    "completeFunctions": 21,
    "missingJSDocCount": 34,
    "incompleteJSDocCount": 0,
    "inaccurateJSDocCount": 0,
    "coveragePercentage": "38.18",
    "completenessPercentage": "38.18",
    "brokenLinksCount": 0,
    "invalidExamplesCount": 0,
    "criticalErrors": 0
  },
  "jsdocAnalysis": {
    "missingJSDoc": [
      {
        "file": "lib/tools/APIRequest.class.js",
        "name": "object",
        "type": "class"
      },
      {
        "file": "lib/tools/APIRequest.class.js",
        "name": "and",
        "type": "class"
      },
      {
        "file": "lib/tools/APIRequest.class.js",
        "name": "as",
        "type": "class"
      },
      {
        "file": "lib/tools/APIRequest.class.js",
        "name": "can",
        "type": "class"
      },
      {
        "file": "lib/tools/APIRequest.class.js",
        "name": "can.call",
        "type": "method"
      },
      {
        "file": "lib/tools/APIRequest.class.js",
        "name": "object",
        "type": "class"
      },
      {
        "file": "lib/tools/APIRequest.class.js",
        "name": "object.call",
        "type": "method"
      },
      {
        "file": "lib/tools/AWS.classes.js",
        "name": "AWS",
        "type": "class"
      },
      {
        "file": "lib/tools/CachedParametersSecrets.classes.js",
        "name": "CachedParameterSecrets",
        "type": "class"
      },
      {
        "file": "lib/tools/CachedParametersSecrets.classes.js",
        "name": "CachedParameterSecret",
        "type": "class"
      },
      {
        "file": "lib/tools/CachedParametersSecrets.classes.js",
        "name": "CachedParameterSecret.write",
        "type": "method"
      },
      {
        "file": "lib/tools/ClientRequest.class.js",
        "name": "for",
        "type": "class"
      },
      {
        "file": "lib/tools/Connections.classes.js",
        "name": "Connections",
        "type": "class"
      },
      {
        "file": "lib/tools/Connections.classes.js",
        "name": "ConnectionAuthentication.if",
        "type": "method"
      },
      {
        "file": "lib/tools/Connections.classes.js",
        "name": "ConnectionAuthentication.if",
        "type": "method"
      },
      {
        "file": "lib/tools/DebugAndLog.class.js",
        "name": "for",
        "type": "class"
      },
      {
        "file": "lib/tools/DebugAndLog.class.js",
        "name": "DebugAndLog",
        "type": "class"
      },
      {
        "file": "lib/tools/DebugAndLog.class.js",
        "name": "is",
        "type": "class"
      },
      {
        "file": "lib/tools/DebugAndLog.class.js",
        "name": "error",
        "type": "function"
      },
      {
        "file": "lib/tools/DebugAndLog.class.js",
        "name": "warn",
        "type": "function"
      },
      {
        "file": "lib/tools/DebugAndLog.class.js",
        "name": "log",
        "type": "function"
      },
      {
        "file": "lib/tools/DebugAndLog.class.js",
        "name": "info",
        "type": "function"
      },
      {
        "file": "lib/tools/DebugAndLog.class.js",
        "name": "debug",
        "type": "function"
      },
      {
        "file": "lib/tools/RequestInfo.class.js",
        "name": "that",
        "type": "class"
      },
      {
        "file": "lib/tools/RequestInfo.class.js",
        "name": "CustomRequestInfo",
        "type": "class"
      },
      {
        "file": "lib/tools/RequestInfo.class.js",
        "name": "construction",
        "type": "class"
      },
      {
        "file": "lib/tools/Response.class.js",
        "name": "for",
        "type": "class"
      },
      {
        "file": "lib/tools/Response.class.js",
        "name": "Response",
        "type": "class"
      },
      {
        "file": "lib/tools/Response.class.js",
        "name": "with",
        "type": "class"
      },
      {
        "file": "lib/tools/Response.class.js",
        "name": "with",
        "type": "class"
      },
      {
        "file": "lib/tools/ResponseDataModel.class.js",
        "name": "for",
        "type": "class"
      },
      {
        "file": "lib/tools/ResponseDataModel.class.js",
        "name": "ResponseDataModel",
        "type": "class"
      },
      {
        "file": "lib/tools/Timer.class.js",
        "name": "for",
        "type": "class"
      },
      {
        "file": "lib/tools/Timer.class.js",
        "name": "Timer",
        "type": "class"
      }
    ],
    "incompleteJSDoc": [],
    "inaccurateJSDoc": []
  },
  "linkValidation": {
    "totalLinks": 153,
    "validLinks": 153,
    "brokenLinks": [],
    "filesChecked": 13
  },
  "exampleValidation": {
    "totalExamples": 168,
    "validExamples": 168,
    "invalidExamples": [],
    "filesChecked": 11
  },
  "fileAnalyses": [
    {
      "filePath": "index.js",
      "exports": []
    },
    {
      "filePath": "lib/dao-cache.js",
      "exports": [
        {
          "type": "class",
          "name": "Cache",
          "hasJSDoc": true,
          "jsdoc": {
            "description": "The Cache object handles the settings for the cache system Before using it must be initialized. Many settings can be set through Environment variables or by passing parameters to Cache.init(): Cache.init({parameters}); Then you can then make a request, sending it through CacheableDataAccess:  const { cache } = require(\"@63klabs/cache-data\"); const cacheObj = await cache.CacheableDataAccess.getData( \tcacheCfg, \tyourFetchFunction, \tconn, \tdaoQuery );",
            "params": [],
            "returns": null,
            "examples": [
              "// Initialize the cache system\nCache.init({\n  dynamoDbTable: 'my-cache-table',\n  s3Bucket: 'my-cache-bucket',\n  idHashAlgorithm: 'sha256'\n});\n// Create a cache instance with connection and profile\nconst connection = { host: 'api.example.com', path: '/data' };\nconst cacheProfile = {\n  defaultExpirationInSeconds: 300,\n  encrypt: true\n};\nconst cacheInstance = new Cache(connection, cacheProfile);\n/"
            ],
            "throws": []
          },
          "position": 53723
        },
        {
          "type": "class",
          "name": "CacheableDataAccess",
          "hasJSDoc": true,
          "jsdoc": {
            "description": "The CacheableDataAccess object provides an interface to the cache. It is responsible for reading from and writing to cache. All requests to data go through the cache Before using CacheableDataAccess, the Cache must be initialized.",
            "params": [],
            "returns": null,
            "examples": [
              "// Init should be done outside the handler\nCache.init({parameters});\n// Then you can then make a request in the handler\n// sending it through CacheableDataAccess:\nconst { cache } = require(\"@63klabs/cache-data\");\nconst cacheObj = await cache.CacheableDataAccess.getData(\n\tcacheCfg,\n\tyourFetchFunction,\n\tconn,\n\tdaoQuery\n);\n/"
            ],
            "throws": []
          },
          "position": 116624
        }
      ]
    },
    {
      "filePath": "lib/dao-endpoint.js",
      "exports": []
    },
    {
      "filePath": "lib/tools/APIRequest.class.js",
      "exports": [
        {
          "type": "class",
          "name": "object",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 1180
        },
        {
          "type": "class",
          "name": "and",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 1263
        },
        {
          "type": "class",
          "name": "as",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 1282
        },
        {
          "type": "class",
          "name": "can",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 10019
        },
        {
          "type": "method",
          "name": "can.call",
          "className": "can",
          "isStatic": false,
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "actualParams": [],
          "position": 10108
        },
        {
          "type": "class",
          "name": "object",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 10046
        },
        {
          "type": "method",
          "name": "object.call",
          "className": "object",
          "isStatic": false,
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "actualParams": [],
          "position": 10108
        },
        {
          "type": "class",
          "name": "APIRequest",
          "hasJSDoc": true,
          "jsdoc": {
            "description": "Submit GET and POST requests and handle responses. This class can be used in a DAO class object within its call() method.",
            "params": [],
            "returns": null,
            "examples": [
              "async call() {\n     var response = null;\n        try {\n            var apiRequest = new tools.APIRequest(this.request);\n            response = await apiRequest.send();\n        } catch (error) {\n            DebugAndLog.error(`Error in call: ${error.message}`, error.stack);\n            response = tools.APIRequest.responseFormat(false, 500, \"Error in call()\");\n        }\n       return response;\n    };\n/"
            ],
            "throws": []
          },
          "position": 10563
        }
      ]
    },
    {
      "filePath": "lib/tools/AWS.classes.js",
      "exports": [
        {
          "type": "class",
          "name": "AWS",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 2394
        },
        {
          "type": "class",
          "name": "AWS",
          "hasJSDoc": true,
          "jsdoc": {
            "description": "AWS Helper Functions - Functions to perform common get and put operations for DynamoDB, S3, and SSM parameter store. Uses AWS SDK v2 or v3 depending on the Node.js version. It will perform this check for you and utilize the proper SDK.",
            "params": [],
            "returns": null,
            "examples": [
              "ssmParams1 = await AWS.ssm.getByName(query);\nssmParams2 = await AWS.ssm.getByPath(query);\nAWS.ssm.client; // access the SSM Client\nAWS.ssm.sdk; // access the SSM SDK (V3 contains { SSM, SSMClient, GetParameterCommand, PutParameterCommand })\n@class AWS\n@property {string} NODE_VER\n@property {number} NODE_VER_MAJOR\n@property {number} NODE_VER_MINOR\n@property {number} NODE_VER_PATCH\n@property {string} NODE_VER_MAJOR_MINOR\n@property {string} SDK_VER 'V2' or 'V3'\n@property {boolean} SDK_V2 true if using AWS SDK v2\n@property {boolean} SDK_V3 true if using AWS SDK v3\n@property {string} REGION AWS region grabbed from Node process.env.AWS_REGION. If not set uses 'us-east-1'\n@property {object} dynamo\n@property {object} dynamo.client DynamoDb Document client (either V2 or V3)\n@property {object} dynamo.sdk V2: { DynamoDb }, V3: { DynamoDB, DynamoDBClient, DynamoDBDocumentClient, GetCommand, PutCommand }\n@property {object} dynamo.put function(params) Given a DynamoDb param object, uses the correct SDK version to perform a DynamoDb put command\n@property {object} dynamo.get function(params) Given a DynamoDb param object, uses the correct SDK version to perform a DynamoDb get command\n@property {object} dynamo.scan function(params) Given a DynamoDb param object, uses the correct SDK version to perform a DynamoDb scan command\n@property {object} dynamo.delete function(params) Given a DynamoDb param object, uses the correct SDK version to perform a DynamoDb delete command\n@property {object} dynamo.update function(params) Given a DynamoDb param object, uses the correct SDK version to perform a DynamoDb update command\n@property {object} s3\n@property {object} s3.client S3 client (either V2 or V3)\n@property {object} s3.sdk V2: { S3 }, V3: { S3Client, GetObjectCommand, PutObjectCommand }\n@property {object} s3.put function(params) Given an S3 param object, uses the correct SDK version to perform a S3 put command\n@property {object} s3.get function(params) Given an S3 param object, uses the correct SDK version to perform a S3 get command\n@property {object} ssm\n@property {object} ssm.client SSM client (either V2 or V3)\n@property {object} ssm.sdk V2: { SSM }, V3: { SSMClient, GetParameterCommand, GetParametersByPathCommand }\n@property {object} ssm.getByName function(query) Given SSM Parameter Store query, uses the correct SDK version to perform the getParameters command\n@property {object} ssm.getByPath function(query) Given SSM Parameter Store query, uses the correct SDK version to perform the getParametersByPath command\n@property {object} AWSXRay\n/"
            ],
            "throws": []
          },
          "position": 4803
        }
      ]
    },
    {
      "filePath": "lib/tools/CachedParametersSecrets.classes.js",
      "exports": [
        {
          "type": "class",
          "name": "CachedParameterSecrets",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 974
        },
        {
          "type": "class",
          "name": "CachedParameterSecrets",
          "hasJSDoc": true,
          "jsdoc": {
            "description": "@class CachedParameterSecrets - Container class for CachedParameterSecret objects",
            "params": [],
            "returns": null,
            "examples": [
              "// Create parameters and secrets\nconst dbPassword = new CachedSSMParameter('/myapp/db/password');\nconst apiKey = new CachedSecret('myapp-api-key');\n// Prime all parameters and secrets before use\nawait CachedParameterSecrets.prime();\n// Get all names\nconst names = CachedParameterSecrets.getNames();\nconsole.log(names); // ['/myapp/db/password', 'myapp-api-key']\n// Get specific parameter\nconst param = CachedParameterSecrets.get('/myapp/db/password');\nconst value = await param.getValue();\n/"
            ],
            "throws": []
          },
          "position": 1606
        },
        {
          "type": "class",
          "name": "CachedParameterSecret",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 4236
        },
        {
          "type": "method",
          "name": "CachedParameterSecret.write",
          "className": "CachedParameterSecret",
          "isStatic": false,
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "actualParams": [
            "data"
          ],
          "position": 4946
        },
        {
          "type": "class",
          "name": "CachedParameterSecret",
          "hasJSDoc": true,
          "jsdoc": {
            "description": "@class CachedParameterSecret - Base class for CachedSSMParameter and CachedSecret Accesses data through Systems Manager Parameter Store and Secrets Manager Lambda Extension Since the Lambda Extension runs a localhost via http, it handles it's own http request. Also, since the lambda extension needs time to boot during a cold start, it is not available during the regular init phase outside of the handler. Therefore, we can pass the Object to be used as the secret and then perform an async .get() or .getValue() at runtime. If we need to use a synchronous function, then we must perform a .prime() and make sure it is complete before calling the sync function.",
            "params": [],
            "returns": null,
            "examples": [
              "const write(data) {\n \tconst edata = encrypt(data, myParam.sync_getValue()); // some encrypt function\n \treturn edata;\n }\nasync main () => {\n \tconst myParam = new CachedSSMParameter('myParam');\n \tmyParam.prime(); // gets things started in the background\n \t// ... some code that may take a few ms to run ...\n \t// We are going to call a sync function that MUST\n \t// have the myParam value resolved so we\n \t// make sure we are good to go before proceeding\n \tawait myParam.prime();\n \tconsole.log(write(data));\n}\n/"
            ],
            "throws": []
          },
          "position": 5505
        },
        {
          "type": "class",
          "name": "CachedSSMParameter",
          "hasJSDoc": true,
          "jsdoc": {
            "description": "CachedSSMParameter extends CachedParameterSecret and is used to retrieve parameters from AWS Systems Manager Parameter Store @extends CachedParameterSecret",
            "params": [],
            "returns": null,
            "examples": [
              "// Use with synchronous functions after priming\nconst apiKey = new CachedSSMParameter('/myapp/api/key');\nasync function init() {\n  // Prime the parameter in the background\n  apiKey.prime();\n  // Do other initialization work...\n  // Ensure parameter is loaded before sync usage\n  await apiKey.prime();\n  // Now safe to use in sync functions\n  const key = apiKey.sync_getValue();\n  return key;\n}\n/"
            ],
            "throws": []
          },
          "position": 15658
        },
        {
          "type": "class",
          "name": "CachedSecret",
          "hasJSDoc": true,
          "jsdoc": {
            "description": "CachedSecret extends CachedParameterSecret and is used to retrieve secrets from AWS Secrets Manager @extends CachedParameterSecret",
            "params": [],
            "returns": null,
            "examples": [
              "// Prime multiple secrets at once\nconst secret1 = new CachedSecret('secret-1');\nconst secret2 = new CachedSecret('secret-2');\n// Prime all secrets in parallel\nawait CachedParameterSecrets.prime();\n// Now all secrets are loaded and cached\nconst value1 = secret1.sync_getValue();\nconst value2 = secret2.sync_getValue();\n/"
            ],
            "throws": []
          },
          "position": 17292
        }
      ]
    },
    {
      "filePath": "lib/tools/ClientRequest.class.js",
      "exports": [
        {
          "type": "class",
          "name": "ClientRequest",
          "hasJSDoc": true,
          "jsdoc": {
            "description": "Extends RequestInfo Can be used to create a custom ClientRequest object",
            "params": [],
            "returns": null,
            "examples": [
              "// Use in Lambda handler\nexports.handler = async (event, context) => {\n  const clientRequest = new ClientRequest(event, context);\n  if (!clientRequest.isValid()) {\n    return { statusCode: 400, body: 'Invalid request' };\n  }\n  const userId = clientRequest.getPathAt(1);\n  const queryParams = clientRequest.getQueryStringParameters();\n  // Add logging for monitoring\n  clientRequest.addPathLog(`users/${userId}`);\n  clientRequest.addQueryLog(`limit=${queryParams.limit}`);\n  // Process request...\n  return { statusCode: 200, body: 'Success' };\n};\n/"
            ],
            "throws": []
          },
          "position": 1366
        },
        {
          "type": "class",
          "name": "for",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 3253
        }
      ]
    },
    {
      "filePath": "lib/tools/Connections.classes.js",
      "exports": [
        {
          "type": "class",
          "name": "Connections",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 448
        },
        {
          "type": "class",
          "name": "Connections",
          "hasJSDoc": true,
          "jsdoc": {
            "description": "@class Connections @property {object} _connections An object containing Connection objects",
            "params": [],
            "returns": null,
            "examples": [
              "// Add connections dynamically\nconst connections = new Connections();\nconnections.add({ name: 'database', host: 'db.example.com', path: '/query' });\nconnections.add({ name: 'cache', host: 'cache.example.com', path: '/get' });\n// Use with endpoint requests\nconst dbConn = connections.get('database');\nconst result = await endpoint.get(dbConn);\n/"
            ],
            "throws": []
          },
          "position": 1319
        },
        {
          "type": "class",
          "name": "Connection",
          "hasJSDoc": true,
          "jsdoc": {
            "description": "The Connection object provides the base for requests but does not carry the request. myConnection.get() will return an object (associative array) that can then be used to generate and submit a request to a DAO class or APIRequest object. You can store and manage multiple connections using the Connections object.",
            "params": [],
            "returns": null,
            "examples": [
              "// Create connection with cache configuration\nconst cachedConn = new Connection({\n  name: 'cachedAPI',\n  host: 'api.example.com',\n  path: '/data',\n  cache: {\n    profile: 'default',\n    expirationInSeconds: 300\n  }\n});\n/"
            ],
            "throws": []
          },
          "position": 4234
        },
        {
          "type": "class",
          "name": "ConnectionAuthentication",
          "hasJSDoc": true,
          "jsdoc": {
            "description": "ConnectionAuthentication allows auth tokens, parameters, etc to be stored separately from regular connection request parameters so that they can be protected from modification or accidental access. Header, parameter, and/or Basic auth key/value pairs can be passed in. Additional methods could be added in the future.",
            "params": [],
            "returns": null,
            "examples": [
              "// Use with Connection\nconst connection = new Connection({\n  name: 'secureAPI',\n  host: 'api.example.com',\n  path: '/secure/data',\n  authentication: new ConnectionAuthentication({\n    headers: { 'Authorization': 'Bearer token123' }\n  })\n});\n/"
            ],
            "throws": []
          },
          "position": 11955
        },
        {
          "type": "method",
          "name": "ConnectionAuthentication.if",
          "className": "ConnectionAuthentication",
          "isStatic": false,
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "actualParams": [
            "obj !"
          ],
          "position": 12193
        },
        {
          "type": "method",
          "name": "ConnectionAuthentication.if",
          "className": "ConnectionAuthentication",
          "isStatic": false,
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "actualParams": [
            "\"parameters\" in obj && obj.parameters !"
          ],
          "position": 12280
        },
        {
          "type": "class",
          "name": "ConnectionRequest",
          "hasJSDoc": true,
          "jsdoc": {
            "description": "A Connection provides the base for a ClientRequest. A ClientRequest extends the Connection by adding request specific parameters. While a Connection cannot be modified after creation (it is a config), a ClientRequest can be modified as the application or DAO assembles the request.",
            "params": [],
            "returns": null,
            "examples": [
              "// Build a request dynamically in a DAO\nclass UsersDAO {\n  static async getUser(userId, authToken) {\n    const request = new ConnectionRequest({\n      host: 'api.example.com',\n      path: `/users/${userId}`\n    });\n    request.addHeaders({\n      'Authorization': `Bearer ${authToken}`,\n      'Content-Type': 'application/json'\n    });\n    return await endpoint.get(request);\n  }\n}\n/"
            ],
            "throws": []
          },
          "position": 16665
        }
      ]
    },
    {
      "filePath": "lib/tools/DebugAndLog.class.js",
      "exports": [
        {
          "type": "class",
          "name": "for",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 244
        },
        {
          "type": "class",
          "name": "DebugAndLog",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 535
        },
        {
          "type": "class",
          "name": "DebugAndLog",
          "hasJSDoc": true,
          "jsdoc": {
            "description": "A comprehensive debug and logging class for managing application logging with environment-aware log levels. Provides multiple logging levels (ERROR, WARN, INFO, MSG, DIAG, DEBUG) and automatic environment detection. Supports both production and development environments with appropriate log level restrictions. @class DebugAndLog",
            "params": [],
            "returns": null,
            "examples": [
              "// Configure via environment variables\n// Set CACHE_DATA_LOG_LEVEL=5 for DEBUG level\n// Set CACHE_DATA_ENV=DEV for development environment\n/"
            ],
            "throws": []
          },
          "position": 1013
        },
        {
          "type": "class",
          "name": "is",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 2234
        },
        {
          "type": "function",
          "name": "error",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "actualParams": [
            "tag",
            "message",
            "obj"
          ],
          "position": 14795
        },
        {
          "type": "function",
          "name": "warn",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "actualParams": [
            "tag",
            "message",
            "obj"
          ],
          "position": 14871
        },
        {
          "type": "function",
          "name": "log",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "actualParams": [
            "tag",
            "message",
            "obj"
          ],
          "position": 14945
        },
        {
          "type": "function",
          "name": "info",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "actualParams": [
            "tag",
            "message",
            "obj"
          ],
          "position": 15017
        },
        {
          "type": "function",
          "name": "debug",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "actualParams": [
            "tag",
            "message",
            "obj"
          ],
          "position": 15091
        }
      ]
    },
    {
      "filePath": "lib/tools/ImmutableObject.class.js",
      "exports": [
        {
          "type": "class",
          "name": "ImmutableObject",
          "hasJSDoc": true,
          "jsdoc": {
            "description": "Create an object that is able to return a copy and not a reference to its properties.",
            "params": [],
            "returns": null,
            "examples": [
              "// Use for connection configurations\nconst connections = new ImmutableObject({\n  api: { host: 'api.example.com', path: '/v1' },\n  auth: { host: 'auth.example.com', path: '/oauth' }\n});\nconnections.finalize();\n// Each get() returns a fresh copy\nconst apiConn1 = connections.get('api');\nconst apiConn2 = connections.get('api');\napiConn1.path = '/v2'; // apiConn2 is unaffected\n/"
            ],
            "throws": []
          },
          "position": 1242
        }
      ]
    },
    {
      "filePath": "lib/tools/RequestInfo.class.js",
      "exports": [
        {
          "type": "class",
          "name": "that",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 268
        },
        {
          "type": "class",
          "name": "CustomRequestInfo",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 1236
        },
        {
          "type": "class",
          "name": "RequestInfo",
          "hasJSDoc": true,
          "jsdoc": {
            "description": "Processes the request from the event data. Parses out client details such as ip and user agent. May be extended to provide custom processing for the application.",
            "params": [],
            "returns": null,
            "examples": [
              "// Get request data as object\nconst requestInfo = new RequestInfo(event);\nconst fullData = requestInfo.toObject(true); // Include sensitive data\nconst safeData = requestInfo.toObject(); // Sensitive data stripped\n/"
            ],
            "throws": []
          },
          "position": 1688
        },
        {
          "type": "class",
          "name": "construction",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 2019
        }
      ]
    },
    {
      "filePath": "lib/tools/Response.class.js",
      "exports": [
        {
          "type": "class",
          "name": "for",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 442
        },
        {
          "type": "class",
          "name": "Response",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 736
        },
        {
          "type": "class",
          "name": "with",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 1006
        },
        {
          "type": "class",
          "name": "Response",
          "hasJSDoc": true,
          "jsdoc": {
            "description": "Response class for creating and managing HTTP responses with support for multiple content types. Provides methods to build, customize, and finalize responses for Lambda functions or web services. Supports JSON, HTML, XML, RSS, and TEXT content types with automatic content type detection. @class Response",
            "params": [],
            "returns": null,
            "examples": [
              "// Initialize Response class with custom settings\nResponse.init({\n  settings: {\n    errorExpirationInSeconds: 180,\n    routeExpirationInSeconds: 3600,\n    contentType: Response.CONTENT_TYPE.JSON\n  }\n});\n/"
            ],
            "throws": []
          },
          "position": 1211
        },
        {
          "type": "class",
          "name": "with",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 2934
        }
      ]
    },
    {
      "filePath": "lib/tools/ResponseDataModel.class.js",
      "exports": [
        {
          "type": "class",
          "name": "for",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 68
        },
        {
          "type": "class",
          "name": "ResponseDataModel",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 422
        },
        {
          "type": "class",
          "name": "ResponseDataModel",
          "hasJSDoc": true,
          "jsdoc": {
            "description": "ResponseDataModel class for collecting and structuring response data. Provides methods to build complex response objects by adding items with keys or as array elements. Supports creating structured skeletons during construction and filling them during execution. Handles key collisions by converting single values to arrays when duplicate keys are added. @class ResponseDataModel",
            "params": [],
            "returns": null,
            "examples": [
              "// Add items to array\nconst list = new ResponseDataModel(null, 'items');\nlist.addItem({ id: 1 });\nlist.addItem({ id: 2 });\nconsole.log(list.toString());\n// Output: {\"items\":[{\"id\":1},{\"id\":2}]}\n/"
            ],
            "throws": []
          },
          "position": 1058
        }
      ]
    },
    {
      "filePath": "lib/tools/Timer.class.js",
      "exports": [
        {
          "type": "class",
          "name": "for",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 72
        },
        {
          "type": "class",
          "name": "Timer",
          "hasJSDoc": false,
          "jsdoc": {
            "description": null,
            "params": [],
            "returns": null,
            "examples": [],
            "throws": []
          },
          "position": 233
        },
        {
          "type": "class",
          "name": "Timer",
          "hasJSDoc": true,
          "jsdoc": {
            "description": "Timer class for measuring execution time and tracking performance metrics. Provides methods to start, stop, and query elapsed time with diagnostic logging. @class Timer",
            "params": [],
            "returns": null,
            "examples": [
              "// Create timer without auto-start\nconst timer = new Timer('delayedOperation');\nawait timer.start();\n// ... perform operation ...\ntimer.stop();\n/"
            ],
            "throws": []
          },
          "position": 628
        }
      ]
    },
    {
      "filePath": "lib/tools/generic.response.html.js",
      "exports": []
    },
    {
      "filePath": "lib/tools/generic.response.json.js",
      "exports": []
    },
    {
      "filePath": "lib/tools/generic.response.rss.js",
      "exports": []
    },
    {
      "filePath": "lib/tools/generic.response.text.js",
      "exports": []
    },
    {
      "filePath": "lib/tools/generic.response.xml.js",
      "exports": []
    },
    {
      "filePath": "lib/tools/index.js",
      "exports": [
        {
          "type": "class",
          "name": "_ConfigSuperClass",
          "hasJSDoc": true,
          "jsdoc": {
            "description": "_ConfigSuperClass needs to be extended by your own Config class definition. This super class holds common variables and methods that can be used by any application. However, each application requires it's own methods and logic to init. Usage: The child class Config should be placed near the top of the script file outside of the event handler. It should be global and must be initialized.",
            "params": [],
            "returns": null,
            "examples": [
              "class Config extends tools._ConfigSuperClass {\n\t\t// your custom class definition including your implementation of .init()\n}\nConfig.init();\n/"
            ],
            "throws": []
          },
          "position": 4027
        }
      ]
    },
    {
      "filePath": "lib/tools/utils.js",
      "exports": []
    },
    {
      "filePath": "lib/tools/vars.js",
      "exports": []
    },
    {
      "filePath": "lib/utils/InMemoryCache.js",
      "exports": [
        {
          "type": "class",
          "name": "InMemoryCache",
          "hasJSDoc": true,
          "jsdoc": {
            "description": "InMemoryCache - Ultra-fast in-memory L0 cache for AWS Lambda Provides microsecond-level cache access using JavaScript Map with LRU eviction. Designed for Lambda execution model with synchronous operations and no background processes.",
            "params": [],
            "returns": null,
            "examples": [
              "// Clear cache when needed\ncache.clear();\nconsole.log('Cache cleared');\n/"
            ],
            "throws": []
          },
          "position": 1443
        }
      ]
    }
  ]
}